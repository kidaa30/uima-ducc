% 
% Licensed to the Apache Software Foundation (ASF) under one
% or more contributor license agreements.  See the NOTICE file
% distributed with this work for additional information
% regarding copyright ownership.  The ASF licenses this file
% to you under the Apache License, Version 2.0 (the
% "License"); you may not use this file except in compliance
% with the License.  You may obtain a copy of the License at
% 
%   http://www.apache.org/licenses/LICENSE-2.0
% 
% Unless required by applicable law or agreed to in writing,
% software distributed under the License is distributed on an
% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
% KIND, either express or implied.  See the License for the
% specific language governing permissions and limitations
% under the License.
% 

      \section{Overview.} 
      A DUCC service is defined by the following two criteria:
      \begin{itemize}
          \item A service is one or more long-running processes that await requests
            and return something in response. 
          \item A service that is managed by DUCC is accompanied by a small program called a
            ``pinger'' that the DUCC Service Manager uses to gauge the availability and health of
            the service.  This pinger must always be be present. However, DUCC will supply a default
            pinger for UIMA-AS services if none is specified.
            
            Users may supply their own ``pingers'' by supplying a Java class that implements
            the pinger API.  This is referred to as a ``custom'' pinger in this document. 
            There are a number of service registration options which  allow
            specification and parameterization of customn pingers.

          \end{itemize}
      The pinger API enables the following functions for custom pingers:
      \begin{itemize}
      \item increase and decrease the number of service instances, 
      \item manage failure restart policies, 
      \item enable and disable service autostart, 
      \item notify the Service Manager of the date of last use of a service, 
      \item notify the Service Manager of the health and availability of a service, 
      \item returns a string for display in the DUCC Web server to show relevent service information
      \end{itemize}
      

      A service is usually a UIMA-AS service, but DUCC supports any arbitrary process as a service.

      The DUCC Service Manager implements several high-level functions:
      
      \begin{itemize}
          \item Ensure services are available for jobs before allowing the jobs to start.
          \item Enable fast-fail for jobs which reference services which are unavailable.
          \item Start a service when it is referenced by a job, and stop it when no longer needed.
          \item Optionally start a service when DUCC is booted.
          \item Insure services remain operational across failures.
          \item Report service failures.
          \item Run service pingers and respond to the pinger API as needed.
       \end{itemize}

       DUCC provides a ``fast-fail'' for work which reference services.  Incoming work which
       references a service is canceled by the system under the following conditions:
       \begin{itemize}
         \item The service is not registered.
         \item The service cannot be started.
         \item The service is started, but the service pinger determines the service is not
           viable.
       \end{itemize}
         
    \section{Service Types.}
    \label{sec:services.types}
      DUCC supports two types of services: UIMA-AS and CUSTOM:
      
      \begin{description}
          \item[UIMA-AS] This is a "normal" UIMA-AS service. DUCC fully supports all aspects of UIMA-AS
            services with minimal effort from developers.  A default pinger is supplied by DUCC
            for UIMA-AS services.  It is legal to define a custom pinger for a UIMA-AS service.
            
          \item[CUSTOM] This is any arbitrary service.  Developers must provide a custom pinger
            and declare it in the service registration.            
      \end{description}

      DUCC also supports services that are not managed by DUCC.  These are known as {\em ping-only}
      services.  The registration for a ping-only service contains only keywords needed to 
      support a pinger.  Ping-only services must be defined as custom services; there is no
      default pinger provided for ping-only services.

      \section{Service References and Endpoints} 
      \label{sec:service.endpoints}
      Services are identified by an entity called a {\em service endpoint}.  Jobs and other
      services use the registered service endpoint to indicate dependencies on specific
      services.

      A service endpoint is of the form 
\begin{verbatim}
      <service-type>:<unique id>
\end{verbatim}
      
      The {\em service-type} must be either UIMA-AS or CUSTOM.
      
      The {\em unique id} is any string needed to ensure the service is
      uniquely named.  For UIMA-AS services, the unique-id must be the same as the
      service endpoint specified in service's DD XML descriptor.  The UIMA-AS
      service endpoint is always of the form:
\begin{verbatim}
      UIMA-AS:queue-name:broker-url
\end{verbatim}
      where {\em queue-name} is the name of the ActiveMQ queue used by the service, and {\em broker-url}
      is the ActiveMQ broker URL.  For example
\begin{verbatim}
      UIMA-AS:WikipediaSearchServices:tcp://broker1:61616
      UIMA-AS:GoogleSearchServices:http://broker2:61618
\end{verbatim}

      Jobs or other services may register dependencies on specific services by listing one or more
      service endpoints int their specifications. See the 
      \hyperref[sec:cli.ducc-submit]{\em job } and 
      \hyperref[sec:cli.ducc-services]{\em services } CLI descriptions for details.
                       
      A service is registered with DUCC using the \hyperref[sec:cli.ducc-services]{ducc\_services}
      API/CLI. Service registrations are persisted by DUCC and last over DUCC and cluster restarts.

      The Service Manager implements three policies for managing services:
      \begin{description}

         \item[Autostarted Services] An autostarted service is automatically started when the DUCC
           system is first booted.  If an instance should die, DUCC automatically restarts the
           instance and continually maintains the registered number of service instances.

           To handle fatal errors in Autostarted Services, The Service Manager maintans a time
           window in which only a specific number of instance failures may occur.  If the number of
           failures within that window of time is excessive DUCC will disable the autostart flag.
           The autostart flag may then be manually reset once the problem is resolved.

           The default failure policy is implemented in the service pingers; therefore, service
           owners may redefine the policy by supplying their own pingers for a service.
          
         \item[Reference-started Services] A reference-started service is a registered service that
           is started only when referenced by another job or service. If the service is already
           started, the dependent job/service is marked ready to schedule as indicated above. If
           not, the service registry is checked and if a matching service is found, it is 
           started by DUCC.  While the service is being started, jobs are held ``Waiting For Services''
           to ensure the service is viable. Once the service has completed initialization and the pinger 
           indicates it is viable, all work waiting on it are then marked ``Services Available'' and
           started.  
          
           When the last job or service that references the on-demand service exits, a timer is
           established to keep the service alive for a while, in anticipation that it will be needed
           again soon.  When the keep-alive timer expires, and there are no more dependent jobs or
           services, the reference-started service is automatically stopped to free up its resources
           for other work.

        \item[Ping-Only Services] 
          \phantomsection\label{subsub:services.ping-only}
          Ping-only services consist of only
          a ping thread.  The service itself is not managed in any way by DUCC.  This is useful for
          managing dependencies on services that are not under DUCC control: the pinger is used
          to assess the viability of the external service and prevent dependent jobs from
          continuing if the service is unavailable.

          Only CUSTOM services may be defined as ping-only services in this version of DUCC.

      \end{description}

      \section{Service Pingers}
      \label{sec:service.pingers}
      A service pinger is a small program that queries a service on behalf of the DUCC Service
      Manager.  A default pinger is provided for UIMA-AS services and provides the following
      functions:
      \begin{itemize}
        \item Determine if the service is responsive by issuing a UIMA-AS ``get-meta'' call 
          to the service.
        \item Determine the health of the service by issuing a JMS call to the UIMA-AS broker
          to collect queueing statistics.
        \item Manages the failure window of the service.
        \item Returns a string with basic ActiveMQ statistics about the service, or
          error information if the service is deemed unusable.
        \item Returns date of last use of the service (as determined by presence or
          absence of service producers attached to the service queue).
      \end{itemize}

      Users may supply their own pingers.  The following functions are available for
      pingers.  Note that a ``custom'' pinger MAY be supplied for UIMA-AS services, and
      MUST be supplied for CUSTOM services.  Custom pingers use the Service Manager's
      ``pinger'' API to perform the following tasks:
      \begin{itemize}
        \item Inform the Service Manager if the service is responsive.
        \item Inform the Service Manager if the service is ``healthy''.  Service ``health''
          is a heuristic used in the DUCC Web server as an alert that a service may
          not be performing well.
        \item Manage service failure policies. The default failure-window policy is
          provided by default to all pingers by the DUCC API handler (optional).
        \item Return a string describing current service status, for use by the
          web server.
        \item Instruct the service manager to increase the number of instances (optional).
        \item Instruct the service manager to decrease the number of instances (optional).
        \item Enable and disable the services autostart flag (optional).
        \item Enable logging of a service's health and state (optional).
        \item Return date of last-use to the Service Manager for display in the
          webserver (optional).
      \end{itemize}

      \subsection{The Pinger API}

      Pingers are provided static  information about the service at pinger-initialization
      time, and subsequently, current state of the service is provided on each call (ping).

      Information provided at initialization consists of the following.  Most of this is
      provided in fields in the {\em AServicePing} base class.  See the Javadoc for 
      specific field names and types.

      \subsubsection{Pinger Initialization Data}
      Data provided once, during pinger intialization, includes:
      \begin{description}
        \item[Arguments] This is the {\em service\_ping\_arguments} string from the
          service registration.
        \item[Endpint] This is the CUSTOM:string or UIMA-AS:string endpoint provided
          in the service registration.
        \item[Monitor Rate] This is the rate at which the pinger will be called by
          the SM, as provided in DUCC's configuration.
        \item[Service ID] This is the unique numeric service ID assigned to the service
          by DUCC.
        \item[Log Enabled] Whether the service log is enable, as specified by the
          {\em service\_ping\_dolog} registration parameter.
        \item[Maximum Allowed Failures] This is the value of the {\em instance\_failures\_limit}
          parameter, provided by DUCC configuration and optionally overridden by the
          service registration.
        \item[Instance Failure Window] This is the value of the {\em instance\_failures\_window}
          prameter, provided by DUCC configuration and optionally overridden by the
          service registration.
        \item[Autostart Enabled] This indicates whether the service registration currently
          has the {\em autostart} flag enabled.
        \item[Last Use] This is the time of last known use of the service, persisted and
          maintained over SM restarts.  It is 0 if unknown or the service has never been
              used.
      \end{description}
        
      \subsubsection{Pinger Dynamic Data}

      Information provided in each call (ping) consists of:
      \begin{description}
        \item[All Instance Information] This is an array consisting of the unique integer
          IDS of all running proceses implementing the service.  This includes instances
          which may not be viable for some reason (still initializing, for example).

        \item[Active Instance Information] This is an array consisting of the unique integer
          IDS of all running proceses implementing the service.  This is a subset of 
          {\em All Instance Information} and includes only the service instance that are advanced
          to Running state, and are thus fully viable.

        \item[Reference Information] This is an array consisting of the unique integer
          IDS of all DUCC work (Jobs, other Services, etc) currently referencing the
          service.  
          
        \item[Autostart Enabled] The current state of the service's autostart flag.
          
        \item[Run Failures] This is the total number of instance failures for the 
          service since the last start of the SM.
      \end{description}

      {\em NOTE:} Numeric DUCC IDs are assigned in a monotonically increasing
      order.  It is therefore possible to determine the relative age of instances by
      ordering the IDs.


      Only a Java API is supported.  Pinters must extend the abstract class,
\begin{verbatim}
      org.apache.uima.ducc.common.AServicePing
\end{verbatim}

      \subsection{Declaring a Pinger in A Service}

      The following registration options are used for declaring and configuring pingers.  Any of these
      may be dynamically modified with the service CLI's {\em$--$modify} option.  Dynamically changing
      these causes the current pinger to be terminated and restarted with the configuration.  See
      \hyperref[sec:cli.ducc-services]{ducc\_services} for details of the options:
      \begin{itemize}
        \item service\_ping\_arguments
        \item service\_ping\_class
        \item service\_ping\_classpath
        \item service\_ping\_jvmargs
        \item service\_ping\_timeout
        \item service\_ping\_dolog
        \item instance\_failures\_window
        \item instance\_failures\_limit
      \end{itemize}

      
      \subsection{Implementing a Pinger}
      Pingers must implement the class {\tt org.apache.uima.ducc.cli.AServicePing}.  See the
      Javadoc for the details of this class.

      Below is a sample CUSTOM pinger for a hypothetical service that returns four integers in
      response to a ping.
      \begin{figure}[H]
\begin{verbatim}
import java.io.DataInputStream;
import java.io.InputStream;
import java.net.Socket;
import org.apache.uima.ducc.cli.AServicePing;
import org.apache.uima.ducc.cli.ServiceStatistics;

public class CustomPing
    extends AServicePing
{
    String host;
    String port;
    public void init(String args, String endpoint) throws Exception {
        // Parse the service endpoint, which is a String of the form 
        //    host:port
        String[] parts = endpoint.split(":");
        host = parts[1];
        port = parts[2];
    }

    public void stop()  {  }

    private long readLong(DataInputStream dis) throws Exception {
        return Long.reverseBytes(dis.readLong());
    }

    public ServiceStatistics getStatistics() {
        // Contact the service, interpret the results, and return a state
        // object for the service.
        ServiceStatistics stats = new ServiceStatistics(false, false,"<NA>");
        try {
            Socket sock = new Socket(host, Integer.parseInt(port));
            DataInputStream dis = new DataInputStream(sock.getInputStream());

            long stat1 = readLong(dis); long stat2 = readLong(dis); 
            long stat3 = readLong(dis); long stat4 = readLong(dis);

            stats.setAlive(true);  stats.setHealthy(true);
            stats.setInfo(  "S1[" + stat1 + "] S2[" + stat2 + 
                            "] S3[" + stat3 + "] S4[" + stat4 + "]" );
        } catch ( Throwable t) {
        	t.printStackTrace();
            stats.setInfo(t.getMessage());
        }
        return stats;        
    }
}
\end{verbatim}
        \caption{Sample UIMA-AS Service Pinger}
        \label{fig:service.custom.pinger}

      \end{figure}
      
      \subsection{Building And Testing Your Pinger}
      This section provides the information needed to use the pinger API and build a
      custom pinger. 

      \paragraph{1. Establish compile CLASSPATH} One DUCC jar is required in the CLASSPATH to build your pinger:
\begin{verbatim}
     $DUCC_HOME/lib/uima-ducc-cli.jar
\end{verbatim}      
      This provides the definition for the {\em AServicePing} and {\em ServiceStatistics} classes.

      \paragraph{2. Create a registration}Next, create a service registration for the pinger.  While
      debugging, it is useful set the directive
\begin{verbatim}
     service_ping_dolog = true
\end{verbatim}
      This will log any output from  {\tt System.out.println()} to your home directory in
\begin{verbatim}
     $HOME/ducc/logs/<serviceid>/services
\end{verbatim}
      where {\tt$<$servicid$>$} is the DUCC-assigned ID of your service.

      Once the pinger is debugged you may want to turn logging off.
\begin{verbatim}
     service_ping_dolog = false
\end{verbatim}
      
      A sample service registration may look something like the following.  Note that you do not need
      to include any of the DUCC jars in the classpath for the pinger.  DUCC will add the jars it
      requires to interact with the pinger automatically.
\begin{verbatim}
     bash-3.2$ cat myping.svc

     description              = Ping-only service
     service_request_endpoint = CUSTOM:localhost:7175
     service_ping_class       = CustomPing
     service_ping_classpath   = /myhome/CustomPing.class
     service_ping_dolog       = true
     service_ping_timeout     = 500
     service_ping_aruments    = Arg1 Arg2
     service_ping_jvm_args   = -DXmx50M
\end{verbatim}
       
      \paragraph{3. Register and start the pinger} Start up your custom service so the pinger has something to contact, then start
      the pinger.  It may be easier to debug the pinger if you initially start the service outside of DUCC. Once
      the pinger is working it is straightforward to integrate it into the pinger's service registration by merging
      the registration for the pinger with the registration for the service.

      That's it!  Check the web server to make sure the service ``comes alive''.  Check your pinger's
      debugging log if it doesn't.  Once registered, you can modify and restart the pinger at any time without
      reregistering the service or restarting the service by use of the {\tt $--$modify} option of the
      ducc\_services CLI:
\begin{verbatim}
     ducc_services --modify <serviceid> --service_ping_dolog true
     ducc_services --modify <serviceid> --service_ping_class OtherCustsomPing
                                        --service_ping_classpath /myhome/OtherCustomPing.class

\end{verbatim}
     where $<$serviceid$>$ is the id returned when you registered the pinger.

     \paragraph{4. If all else fails ...}
     If your pinger does not work and you cannot determine the reason, be sure you enable {\em service\_ping\_dolog} and
     look in your log directory, as most problems with pingers are reflected there.  As a last resort, you can
     inspect the the Service Manager's log in
\begin{verbatim}
     $DUCC_HOME/logs/sm.log
\end{verbatim}
     
    \subsection{Globally Registered Pingers}
    \label{subsec:services.pingers}

    A pinger may be registered with DUCC so that it is available to all users of DUCC services.  To do 
    this, a registration file containing only pinger-specific parameters is created in DUCC's runtime
    directory.   Such a pinger may then be designated for a service by using its registered filename
    instead of its class in the {\em service\_ping\_class} field of a registration.  There is no API or
    CLI to register such a pinger; only a DUCC administrator may create a global ping registration.

    A globally-registered pinger may then be designated to run as a thread inside the SM or as a
    process spawned and managed by the SM. A pinger that runs in a thread in the SM is
    called an {\em internal} pinger, and one that runs in a process is called an {\em external}
    pinger.  An {\em internal} pinger generally has nearly unmeasurable impact on the system,
    whereas {\em external} pingers will occupy full JVMs with processes of 50-100MB or more.
    
    A service may override any of the options of a globally-registered {\em external} pinger,
    thus allowing significant reuse of existing code.  Only the {\em service\_ping\_arguments} 
    of an {\em internal} pinger may be overridden howver.

    The default UIMA-AS pinger is permanently registered as an {\em internal} pinger.

    Details of registering global pingers is found in the 
    \hyperref[chap:sm]{\em Administration section} of this document.

    \subsection{Example}
    
    A sample custom UIMA-AS pinger is provided in the Examples directory shipped 
    with DUCC in
\begin{verbatim}
     examples/src/org/apache/uima/ducc/ping
\end{verbatim}
    
    This pinger increases or decreases the number of service instances based
    on the queue statistics found by querying ActiveMQ.  The goal of this
    pinger is to maintain the ActiveMQ ``enqueued time'' to be no more than
    some multiple of the average service time for a single item.  The multiple
    used is a parameter passed in with the argument string.

    The best way to understand this pinger is to examine the code itself in the
    Examples directory.  A summary of the essential methods follows.

    \paragraph{void init(String args, String ep)}
    This method examines the service arguments and endpoint and establishes a monitor
    to issue {\em get-meta} calls to the service and {\em JMS} calls to the 
    ActiveMq broker.  The following argument string is a single comma-delimeted
    string containing the following initializaton parameters:
    \begin{description}
      \item[meta-timeout]
      \item[broker-jmx-port]
      \item[window]
      \item[enable-log]
      \item[min]
      \item[max]
      \item[max-growth]
      \item[goal]
    \end{description}
    
